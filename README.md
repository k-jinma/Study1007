# 抽象クラスとインターフェースの学習

初めて抽象クラスとインターフェースを学ぶ学生向けの段階的な学習。

---

## 📚 学習の流れ

- **①**: 抽象クラスの学習  
- **②**: インターフェースの学習

---

## 目次

- [1:抽象クラス版](#sec-abstract)
  - [学習目標](#abs-goal)
  - [説明](#abs-explain)
  - [演習問題](#abs-ex)
- [2:インターフェース版](#sec-interface)
  - [学習目標](#int-goal)
  - [学生への説明](#int-explain)
  - [演習問題](#int-ex)
- [@Overrideアノテーションについて](#override)
- [抽象クラス vs インターフェース](#vs)
- [応用演習問題](#advanced)

---

<a id="sec-abstract"></a>

# ①: 抽象クラス版

<a id="abs-goal"></a>

## 学習目標

「商品を表示する方法は、商品の種類によって違う」ことを理解する。

<a id="abs-explain"></a>

## 説明

### 導入の会話

**先生**: 「みんな、今まで商品クラス(Item)を作ってきたよね。ここで質問です。パンとジュースの情報を表示するとき、同じ表示方法でいいかな?」

**学生**: 「パンは賞味期限を表示したいけど、ジュースは容量(ml)を表示したいです」

**先生**: 「そうだよね。でも、表示する処理(displayメソッド)は**全ての商品に必要**だよね?」

**学生**: 「はい」

**先生**: 「これが抽象クラスの出番なんだ。抽象クラスはこう言ってるんだよ:
- 『全ての商品はdisplayメソッドを持ちなさい(約束)』
- 『でも、どう表示するかは各商品が決めなさい(自由)』」

### ポイント整理

**抽象クラスの役割**:
1. **共通部分**: 全商品が持つno, name, priceなどのフィールドとメソッド  
2. **約束**: 「このメソッドは必ず実装してね」という決まり(抽象メソッド)  
3. **自由**: 実装方法は各クラスで自由に決められる  

**なぜ必要?**
- 「displayメソッドを作り忘れた!」を防げる(コンパイルエラーになる)
- Item型の配列で全商品を扱える(ポリモーフィズム)
- プログラムの設計図が明確になる

---

<a id="abs-ex"></a>

### 演習1-1: Magazineクラスの作成

雑誌(Magazine)クラスを作成してください。

**要件**:

- Itemクラスを継承する
- 発売日(releaseDate)をString型で持つ
- displayメソッドでは「雑誌名 価格円 [発売日:○○○○-○○-○○]」と表示する

**例**: "週刊Java 500円 [発売日:2024-10-01]"

### 演習1-2: 特別表示の追加

displayメソッドを工夫して、以下の表示を実現してください:

- 100円未満の商品には「お手頃!」と表示
- 500円以上の商品には「高級品」と表示

**例**: "メロンパン 150円 [賞味期限:2024-10-05] お手頃!"

---

<a id="sec-interface"></a>

# ②: インターフェース版

<a id="int-goal"></a>

## 学習目標

「賞味期限がある商品とない商品がある」ことを理解する。

<a id="int-explain"></a>

## 説明

インターフェースは「できること」の証明書。

### 導入の会話

**先生**: 「コンビニの商品を考えてみよう。賞味期限がある商品とない商品、どっちもあるよね?」

**学生**: 「パンやジュースは賞味期限あり、お菓子は...商品によります」

**先生**: 「そう! つまり『賞味期限がある』っていうのは、**一部の商品だけができること**なんだ。これをインターフェースで表現するんだよ」

**先生**: 「インターフェースPerishable(賞味期限がある)は、こんな意味:

- 『私は賞味期限を持っています』という証明書
- 『getBestBefore()メソッドが使えます』という約束」

### ポイント整理

**インターフェースの役割**:

1. **できること宣言**: 「この機能を持っています」と宣言する
2. **グループ分け**: 賞味期限がある商品だけ特別な処理ができる
3. **柔軟性**: 必要な商品だけ実装すればいい

**なぜ必要?**

- 商品によって持つ機能が違うとき便利
- 「この商品は賞味期限チェックできる?」を判定できる(instanceof)
- 後から新しい機能を追加しやすい

---

<a id="int-ex"></a>

## 演習問題

### 演習2-1: Taxableインターフェースの作成

消費税がかかる商品を表すTaxableインターフェースを作ってください。

**インターフェース内容**:

- int getTaxIncludedPrice() メソッド(税込価格を返す)

**実装**:

- Breadクラスに実装する(消費税10%とする)
- RegisterクラスにshowTaxIncludedPrices()メソッドを追加(税込価格を表示する)

### 演習2-2: 期限切れ判定の追加

Perishableインターフェースに以下を追加してください:

- boolean isExpired(String todayDate) メソッド

**実装**:

- 今日の日付と賞味期限を比較して、期限切れかどうか判定する
- Register.checkExpiredItems()で期限切れ商品に「期限切れ!」と表示

**ヒント**: String型の日付比較は compareTo() メソッドが使えます

例: "2024-10-01".compareTo("2024-10-05") → 負の値(前の日付)

---

<a id="override"></a>

# @Overrideアノテーションについて

（オーバーライドの説明・例・表）

---

<a id="vs"></a>

# 抽象クラス vs インターフェース

### 抽象クラス

- **IS-A関係** (「〜である」)
- パンは商品**である**、ジュースは商品**である**
- 共通の性質や動作がある

### インターフェース

- **CAN-DO関係** (「〜できる」)
- パンは賞味期限チェック**できる**、ジュースも賞味期限チェック**できる**
- 特定の能力や機能を表す

---

<a id="advanced"></a>

# 応用演習問題

### 演習3: 商品管理システムの拡張

以下の要件を満たすシステムを作成してください:

**1. 抽象クラスItemを使う**

- display()抽象メソッド
- getCategory()抽象メソッド(商品カテゴリを返す)

**2. インターフェースを2つ作る**

- Perishable (賞味期限管理)
- Discountable (割引可能)

**3. 以下のクラスを実装**

- Bread: Perishable, Discountable両方を実装
- Drink: Perishableのみ実装
- Snack: Discountableのみ実装

**4. Registerクラスに以下を追加**

- showDiscountableItems() (割引可能商品を表示)
- applyDiscountAll(int rate) (全割引可能商品に割引適用)

---

## ライセンス

このプロジェクトは教育目的で作成されています。自由に使用・改変してください。
